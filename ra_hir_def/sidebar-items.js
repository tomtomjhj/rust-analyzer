initSidebarItems({"enum":[["AdtId","A Data Type"],["AssocItemId",""],["AttrDefId",""],["ContainerId",""],["DefWithBodyId","The defs which have a body."],["GenericDefId",""],["ModuleDefId","The defs which can be visible in the module."],["VariantId",""]],"mod":[["adt","Defines hir-level representation of structs, enums and unions"],["attr","A higher level attributes based on TokenTree, with also some shortcuts."],["body","Defines `Body`: a lowered representation of bodies of functions, statics and consts."],["builtin_type","This module defines built-in types."],["data","Contains basic data about various HIR declarations."],["db","Defines database & queries for name resolution."],["diagnostics","Diagnostics produced by `hir_def`."],["docs","Defines hir documentation."],["expr","This module describes hir-level representation of expressions."],["generics","Many kinds of items or constructs can have generic parameters: functions, structs, impls, traits, etc. This module provides a common HIR for these generic parameters. See also the `Generics` type and the `generics_of` query in rustc."],["lang_item","Collects lang items: items marked with `#[lang = \"...\"]` attribute."],["nameres","This module implements import-resolution/macro expansion algorithm."],["path","A desugared representation of paths like `crate::foo` or `<Type as Trait>::bar`."],["per_ns","In rust, it is possible to have a value, a type and a macro with the same name without conflicts."],["resolver","Name resolution fa√ßade."],["src","Utilities for mapping between hir IDs and the surface syntax."],["type_ref","HIR for references to types. Paths in these are not yet resolved. They can be directly created from an ast::TypeRef, without further queries."]],"struct":[["ConstId",""],["ConstLoc",""],["EnumId",""],["EnumVariantId",""],["FunctionId",""],["FunctionLoc",""],["ImplId",""],["ItemLoc",""],["LocalEnumVariantId",""],["LocalImportId",""],["LocalModuleId","An ID of a module, local to a specific crate"],["LocalStructFieldId",""],["LocationCtx",""],["ModuleId",""],["StaticId",""],["StaticLoc",""],["StructFieldId",""],["StructId",""],["TraitId",""],["TypeAliasId",""],["TypeAliasLoc",""],["UnionId",""]],"trait":[["AstItemDef",""],["HasModule",""],["Lookup",""]]});